
 PUSHING STYLE==>
   for(ll i=0;i<n;i++)
    {
        ll a;cin>>a;
        tree[i+n]=a;
    }

ll tree[2*MAX];ll n;


REMEMBER TO CALL THE BUILD FUNCTION ...
REMEMBER THE QUERY IS FOR [L,R) LEFT INCLUSIVE ,RIGHT EXCLUSIVE
===========================================================================
void build()
{
    for(ll i=n-1;i>0;i--)
    {
        
        tree[i]=tree[i<<1] +  tree[i<<1|1];
        
                  //MODIFY THE SIGN AS PER NEED;
    }
}
void modify(ll val ,ll pos)
{
    
    for(tree[pos+=n]=val;pos>1;pos>>=1)
    {
        tree[pos>>1]=tree[pos]  +   tree[pos^1];
                            //MODIFY THE SIGN AS PER NEED;
    }
}
ll query(ll l,ll r)
{
    ll res=0;
    for(l+=n,r+=n;l<r;l>>=1,r>>=1)
    {
        if(l&1)res+=tree[l++];
        if(r&1)res+=tree[--r];
    }
    return res;
================================================================================
LAZY PROPAGATION IN SEGMENT TREES , RANGE UPDATE AND RANGE QUERY
ARRAY OF NODES IS DECLARED OF SIZE 4*N AS N ELEMENT ,N-1 IN TOTAL ELEMENT ABOVE IT AS IF N=4,SO 1,2,WILL BE THEIR
   1
 2   3
4 5 6 7
ABOVE 1,2,3 REQUIRED THE N-1 AND AFTER THAT FOR PROPAGATING PURPOSE ,AS WE WANT TO KEEP THE ALGORITHM GENERALIZE SO WE ADD ANOTHER 
EG. 
			1
		   2    3
	       4  5  6  7
          8 9 10 11 12 13 14 15
THE NUMBERS FROM 8-15 DONT CONRTIBUTE IN ANYTHING ....BUT HERE 2*N MORE ELEMENTS ARE REQUIRED

REMEMBER UNLIKE THE ABOVE SEGMENT TREE THE QUERY IS  UPDATE[..,L,R,..] L INCLUSIVE AND R INCLUSIVE .
================================================================================
struct node{
    ll val,laze;
    node()
    {
        val=laze=0;
    }
};
ll pos[MAX];
node tree[4*MAX];
//WHAT BUILD DOES IN THE BELOW CODE IS THAT WE PASS BUILD THE PARAMETER BUILD(1,1,END);...
//NOTE THAT HERE U HAVE TO STORE ARRAYS IN 1 INDEXING AND SUPPOSE U HAVE TO ALLOCATE THE VALUES TO THE NODES WHICH CONTAIN INFORMATION OF ONE NODE ,SO THEIR L==R ,BUT HOW TO GET THE INDEX WHERE SUCH NODES ARE PRESENT SO WE PASS 1,SO IF WE GO TO LEFT AND RIGHT CHILD WE GET THE NUMBER... AND THEN STORE THE VALUE

void build(ll num,ll l ,ll r)
{
    if(l==r)
    {
        tree[num].val = //YOUR ARRAY VALUE...;return;
    }
    ll mid = l+r>>1;
    build(num<<1,l,mid);
    build(num<<1|1,mid+1,r);
    push_up(num,l,r);
}
void push_down(ll pos,ll l,ll r)
{
    if(tree[pos].laze!=0)
    {
    tree[pos<<1].laze+=tree[pos].laze;
    tree[pos<<1].val+=tree[pos].laze;
        
    tree[pos<<1 |1].laze+=tree[pos].laze;
    tree[pos<<1 |1].val+=tree[pos].laze;
    tree[pos].laze=0;
    }
}
void push_up(ll pos,ll l,ll r)
{
//L AND R ARE NOT OF ANY USE HERE..
// USED WHEN U HAVE PROPAGATED THE VALUE SO U HAVE TO UPDATE THIS NODE WITH CORRESPONDING TO ITS CHILD...
    tree[pos].val=max(tree[pos<<1].val,tree[pos<<1 |1].val);
       // INSTEAD OF MAX YOU CAN DO ANY OPERATION AS YOU WISH BUT ACCORDINGLY WHAT WILL BE OPERATED IS TO HANDLED
}
void update(ll pos,ll l ,ll r,ll L,ll R,ll val)
{
//HOW TO USE: IN MOST OF THE CASES WE PASS FIRST THREE PARAMETERS:posl,R AS 1,1,R(YOUR END)...L AND R IS THE RANGE U HAVE TO UPDATE WITH VALUE VAL AS THE UPDATE FUNCTION ONLY UPDATES THE NODES WHICH LIE IN INTERVAL... 
    if(L<=l && R>=r)
    {
        tree[pos].laze+=val;
        tree[pos].val+=val;
        return;
    }
    push_down(pos,l,r);
    //PROPAGATING THE LAZE OTHER THAN VAL IF  PRESENT IN THE POS ,SO ITS GETS PROPAGATED IN THE CHILDREN
    ll mid=(l+r)>>1;
    if(L<=mid)update(pos<<1,l,mid,L,R,val);
    if(mid<R)update( pos<<1 | 1,mid+1,r,L,R,val);
    push_up(pos,l,r);
}

========================================================================================================================

PRACTISE PROBLEM: https://codeforces.com/problemset/problem/1320/C
========================================================================================================================
