
 PUSHING STYLE==>
   for(ll i=0;i<n;i++)
    {
        ll a;cin>>a;
        tree[i+n]=a;
    }

ll tree[2*MAX];ll n;


REMEMBER TO CALL THE BUILD FUNCTION ...
REMEMBER THE QUERY IS FOR [L,R) LEFT INCLUSIVE ,RIGHT EXCLUSIVE
===========================================================================
void build()
{
    for(ll i=n-1;i>0;i--)
    {
        
        tree[i]=tree[i<<1] +  tree[i<<1|1];
        
                  //MODIFY THE SIGN AS PER NEED;
    }
}
void modify(ll val ,ll pos)
{
    
    for(tree[pos+=n]=val;pos>1;pos>>=1)
    {
        tree[pos>>1]=tree[pos]  +   tree[pos^1];
                            //MODIFY THE SIGN AS PER NEED;
    }
}
ll query(ll l,ll r)
{
    ll res=0;
    for(l+=n,r+=n;l<r;l>>=1,r>>=1)
    {
        if(l&1)res+=tree[l++];
        if(r&1)res+=tree[--r];
    }
    return res;
================================================================================
LAZY PROPAGATION IN SEGMENT TREES , RANGE UPDATE AND RANGE QUERY
ARRAY OF NODES IS DECLARED OF SIZE 4*N AS N ELEMENT ,N-1 IN TOTAL ELEMENT ABOVE IT AS IF N=4,SO 1,2,WILL BE THEIR
   1
 2   3
4 5 6 7
ABOVE 1,2,3 REQUIRED THE N-1 AND AFTER THAT FOR PROPAGATING PURPOSE ,AS WE WANT TO KEEP THE ALGORITHM GENERALIZE SO WE ADD ANOTHER 
EG. 
			1
		   2    3
	       4  5  6  7
          8 9 10 11 12 13 14 15
THE NUMBERS FROM 8-15 DONT CONRTIBUTE IN ANYTHING ....BUT HERE 2*N MORE ELEMENTS ARE REQUIRED

REMEMBER UNLIKE THE ABOVE SEGMENT TREE THE QUERY IS  UPDATE[..,L,R,..] L INCLUSIVE AND R INCLUSIVE .
================================================================================
struct node{
    ll val,laze;
    node()
    {
        val=laze=0;
    }
};
ll pos[MAX];ll a[MAX];
node tree[4*MAX];
void push_down(ll pos,ll l,ll r)
{
    if(tree[pos].laze!=0)
    {
    tree[pos<<1].laze+=tree[pos].laze;
    tree[pos<<1].val+=tree[pos].laze;
        
    tree[pos<<1 |1].laze+=tree[pos].laze;
    tree[pos<<1 |1].val+=tree[pos].laze;
    tree[pos].laze=0;
    }
}
void push_up(ll pos,ll l,ll r)
{
    tree[pos].val=max(tree[pos<<1].val,tree[pos<<1 |1].val);
       // INSTEAD OF MAX YOU CAN DO ANY OPERATION AS YOU WISH BUT ACCORDINGLY WHAT WILL BE OPERATED IS TO HANDLED
}
void update(ll pos,ll l ,ll r,ll L,ll R,ll val)
{
    if(L<=l && R>=r)
    {
        tree[pos].laze+=val;
        tree[pos].val+=val;
        return;
    }
    push_down(pos,l,r);
    //PROPAGATING THE LAZE OTHER THAN VAL IF  PRESENT IN THE POS ,SO ITS GETS PROPAGATED IN THE CHILDREN
    ll mid=(l+r)>>1;
    if(L<=mid)update(pos<<1,l,mid,L,R,val);
    if(mid<R)update( pos<<1 | 1,mid+1,r,L,R,val);
    push_up(pos,l,r);
}

